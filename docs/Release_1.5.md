# Handy Release 1.5

10 Dec 90

## Update notes

This is my first release. As far as updating your code is concerned, you don't need to do anything to keep up to date with this release. The whole package is devoted to information and an example program for playing back digitized sound on the Lynx. In addition, since there hasn't been any sample code released for controlling stereo Lynxes, I have included code which does stereo panning of the digitized sounds played back in the example program. Have fun with it, and feel free to call me with questions or comments at (408)745-5071. I will also be checking the Atari BBS pretty regularly.

Stephen Jungels, Atari

## Contents of this release

This release contains these release notes, the utility program `DFILT` in the `HANDY:`  directory, the new subdirectory `DigiDemo` in the `6502:Examples` directory, which contains the digitized sound module and example program, and the new subdirectory `DigiSounds` in the `6502:Examples` directory, which contains digital samples used by the demo.

## What you need to do to use this release

With Quarterback, restore the file `HANDY/Dfilt` to the hard disk which contains your `HANDY:` directory. Restore all the files in `6502` to the hard disk which contains your `6502:` directory. None of the files in this release are replacements for existing files, so there are no required changes to your source code if you are not a digitized sound user. If you are, read on.

## DIGI

Many developers have asked about how digitized sounds are done on the Lynx. The games developed so far have all used their own custom playback routines. This package attempts to provide a simple, modular utility which makes it easy to include digitized sounds in any game, and "get your feet wet" with Lynx digitized sound. In order to support games with a small amount of RAM to dedicate to digitized sound, and maintain a simple and easy to implement game interface, DIGI reads its sample data from the ROM cart, requiring only a 256 byte RAM buffer.

### What kind of sampler is the Lynx?

Any digital audio sample is a series of numbers generated by measuring the volume level of an analog signal at evenly spaced time intervals. Following the usual terminology, I
will call a single volume number a "sample value", the whole thing a "sample", the times at which sample values are measured "sample points", the rate at which sample points
happen the "sample rate", and the range of values each sample value can take the "sampling resolution".  Sample rate and sampling resolution determine the fidelity of the sounds a sample playback device can produce.

Now for the Lynx. A Lynx sample gets played by an interrupt routine which stores a sample value to one of the 4 audio output registers each time it executes. (This method
allows a digital sound on one audio channel to play back at the same time as other sounds (perhaps other digital samples, or sounds generated by the standard sound effects driver) play on the other channels.)

The value stored to an audio output register must be an 8 bit two's complement number representing an amplitude in the range `-128..127` (DIGI reserves the value `-128` for an end-of-sample flag).  This sets the Lynx's maximum sampling resolution at 8 bits, although software may use lower resolutions. DIGI uses 8 bit samples.

The maximum sample rate is a little harder to determine. The hardware will generate interrupts at rates well above typical sampling rates and, more important, above the
practical limits set by the performance of the 65c02. All of the following will have an effect on the sample rate a sound can be played at: the efficiency of the interrupt routine, other loads on Mikey and Suzy during playback, the number of samples playing simultaneously, and your desired game speed.

The example program `DIGIDEMO.ROM` allows the sample playback rate to be varied. Up to a sample rate of about 5,000 Hz, the demo runs at a 60 Hz game rate. The game rate drops to 30 Hz at a sample rate of 5 KHz, and 20 Hz at a sample rate of 10 KHz. Above a sample rate of about 15 KHz, the method used by DIGI isn't capable of reading data from the
ROM cart fast enough to prevent buffer wraparounds. 

### Playback methods

The most important factor determining the features of a sample playback routine is whether it plays RAM-based or ROM-based sounds.

A RAM-based routine is fastest. It can play multiple samples simultaneously, but it is a difficult job to work out an overlay scheme for playing back long samples, and large
amounts of RAM will have to be reserved for sample data.

A ROM-based routine is slowed down by the necessity of buffering data from the ROM cart during playback, but its RAM requirements are small, and the length of the samples it can
play is limited only by cart size.  The serial nature of the ROM cart makes it very difficult for a ROM-based routine to play multiple sounds from the cart simultaneously.

Since RAM on the Lynx tends to be pretty scarce, I wrote DIGI as a ROM-based player, with custom routines which decrease the processor time spent doing cart reads considerably.

### Setting the volume

It is desirable for software to be able to vary the overall playback volume of a sample. DIGI provides (optional) volume control by using a 256 byte volume table which contains
the actual output value for each possible sample value. Software can write data to this buffer to set various global volume levels. A routine provided in the package writes
linear data to this table to provide 256 levels of volume from silence to full volume.

### Running the example program

To see the digitized routines work you can run the demo in the `DigiDemo` directory.  Assemble the demo by typing:

```
CD 6502:Examples/DigiDemo
ASM DigiDemo
HANDYROM DigiDemo.hsf
```

Then load and boot the ROM file `DigiDemo.rom`. The game runs at 60 Hz, and it is possible to see the effect on game speed of playing back samples at various rates. (The glider flies back and forth at 1 pixel per frame, and the number in the lower right hand corner is the number of 60 Hz frames used by the last main game loop.)

### Stereo

The demo includes code which will do stereo positioning of the digital sample as it plays back. A Howard board which has the stereo mods will play the sample at 16 different pan
positions from full left to full right. The stereo code in `DigiDemo.src` is collected in the routines `init_my_stereo` and `set_stereo_pan`.

### Using DIGI in your program

#### A. Installation  
  To install DIGI, you need to include the following file in your assembly:  
  `6502:Examples/DigiDemo/Digi.src`
  
In addition, the following switches and constants must be defined:

- `GETDIR_USER`  
  This switch should be defined so that the ROM cart routines include directory code.  
  The launch_sound routine uses `GETDIR` to locate the beginning of the sample file.
- `HSFX_ACTIVE`  
  Defining this switch enables code that tries to allocate an audio channel from HSFX when launching a sound and returns it when the sound is done. It is optional.
- `GRABAUDIO_USER`  
  This switch should be defined if `HSFX_ACTIVE` is defined, to enable the HSFX routine `AllocAudio`.
- `VARIVOLUME`  
  This switch enables code that uses a 256 byte volume table in order to play back digital samples at variable volume levels.
- `DIGICHANNEL`  
  This is the number of the audio channel which will be used to play back samples.
- `DIGITIMER`  
  This is the number of the hardware timer which will be used by the playback routines to generate the sample rate. A number from `0` to `7`.  
  Some of the timers are typically used by the standard system routines:
  - Timers 0 and 2 are always reserved for the vertical and horizontal interrupts.  
  - Timer 4 is the serial baud rate generator.  
  - Timer 6 is for the HSFX/HMUSIC driver, if the game uses it.
  - Timers 1 & 5 are used by Redeye during logon.
  - Timer 1 is used by Redeye during normal communications.
  - Timers 3 and 7 aren't used by any of the system routines, so either one makes a good choice for a sample rate timer.
  - Timer 5 is available after Redeye logon is complete, or always in a non-Redeye game.

DIGI uses several zero page variables to interface with games, which it allocates itself:

- `soundactive`  
  This will be true (`-1`) while the sound interrupt is running.
- `stopsound`  
  This can be set to `-1` to ask for the current sound to be stopped at the end of the next 128 byte segment.
- `volume`  
  If the switch `VARIVOLUME` is defined, this variable selects a volume level from `0` (silence) to `255` (full volume) which is used by the `set_volume` routine to create a volume table.
- `digichannel`  
  If `HSFX_ACTIVE` is defined, this variable will be set to the audio channel allocated by HSFX every time a sample is successfully launched. If `HSFX_ACTIVE` isn't  defined, `digichannel` can be set to any audio channel from `0` to `3`. A changed value of  `digichannel` will go into effect the next time a sound is launched.

In addition, DIGI reserves two zero page variables for its own internal use:

- `loadinprogress`  
  This is used to prevent reentry if a buffer wraparound occurs.
- `cartseg`  
  This keeps track of which 128 byte segment of the cart page is currently being read.

DIGI uses one or two 256 byte buffers which must be allocated for it:

- `soundbuffer`  
  This is the buffer which is used to store sample data to be played back by the sampler interrupt. It must be aligned to an even 256 byte boundary.
- `volumetable`  
  If the switch `VARIVOLUME` is defined, this is where the current volume table values are stored. The volume table doesn't need to be page-aligned.
 
The demo program `DigiDemo.src` has examples of all the switch settings and table allocations listed above.

#### B. Calling the digitized sampler routines

The digitized sampler interfaces with game code through the zero page variables listed above and the following routines: 

```
init_sampler
launch_sound
set_volume
```

The process for using each routine is outlined below:

- `init_sampler`  
  This routine must be called once before any calls to `launch_sound` are made. It installs the sample interrupt, initializes the sampler's variables, and, if the switch `VARIVOLUME` is defined, sets the initial volume to full.  
  Interrupts must be disabled when this routine is called.  
  If there is an `INITINT` in your init code, the call to this routine should come after the `INITINT`, so the sound interrupt address doesn't get overwritten.

- `launch_sound`  
  This routine attempts to play a digital sample. It should be called with the cart file number of the sample to be played in the A-register, the reload value for the sample rate timer in the X-register, and the priority of the sample in the Y-register. If `SAMPLERATE` is the desired sample rate in KHz, then

  ```
  SAMPLERELOAD .eq 1000000/SAMPLERATE 
  ``` 

  will be the right value for the timer reload.

  The priority value in the Y-register is only necessary if the sampler has to share channels with HSFX (the switch `HSFX_ACTIVE` is defined). In that case, `launch_sound` will attempt to allocate an audio channel. If it fails, no sound will play and `soundactive` will remain `false` (`0`).

  Otherwise, soundactive will be set to `true` (`-1`) and the sound will begin playing.  The zero page variable `digichannel` will be set to the audio channel used for playing the sample. `soundactive` will remain `true` as long as the sound is playing, and then drop to zero.

  A game can stop an active sound by setting the variable `stopsound` to `-1`. The sound will stop playing at the end of the current 128 byte segment, and `soundactive` will drop to zero. The demo program shows how to use `soundactive` and `stopsound` to launch a new sound while a previously launched sound is still active (see the routine `play_sample` in `DigiDemo.src`).
-  `set_volume`
  If the switch `VARIVOLUME` is defined, a global volume level can be set by setting the zero page variable `volume` to a number between `0` (silence) and `255` (full volume) and calling `set_volume`.
    
#### C. Getting digital samples onto the cart

The sample files played by the digital audio routines should be in the following format:

- Each file should begin on an even cart page boundary.
- Data consist of 8 bit 2-s complement sample values.  
  The value `128` is reserved for an end-of-sample flag.
- The file should be terminated by one end-of-sample byte (`128`)

Assuming you have created a digital sample using your favorite sampler and sound editing tools (see the section below, "Notes on creating digitized sounds for the Lynx"), the
following steps are needed to get the sample data onto a game cart:

- Save the sample as raw 8 bit data, or translate the IFF files written by your editor into raw format.
- Run the program `DFILT` (included with this release) on the raw data file. `DFILT` just discards all sample values of `128`, discards an optional number of header bytes, and writes a terminating `128` after the end of the sample data. `DFILT` reads from and writes to the same file, so just type

  ```
  > DFILT sound.raw,
  ```

  for example. `DFILT` will also translate several files at once; just type additional filenames on the command line.
- Include a file entry in your HandyROM `.hsf` file for the sample. The HandyROM `ALIGN` directive should be used to align the first byte of the file to an even cart page boundary. For example:

  ```
  FILE SOUND_FILE
  ALIGN ROMPAGESIZE
  RAW SOUND.RAW
  ```

### Notes on creating digitized sounds for the Lynx

There are several hardware and software packages available for creating and editing digitized samples on the Amiga. Amiga experts will have their favorites; all that's needed to make samples work with DIGI is some method of writing raw 8 bit samples. The standard Amiga format is IFF 8SVX, which includes header information DIGI doesn't use, but programs that translate IFF sound files to raw format are widely available. For those of you who don't have sample tools, here is some information on our setup at Atari.

For creating samples we use PerfectSound 3.1, from SunRize Industries. PerfectSound also includes a simple editing tool which may be fine for many uses. It has digital effects,
resampling functions, and an on screen waveform editor with cut, paste, and the usual editing tools. It will save files in raw format, so there is no need to use a separate
conversion program.

Most of our sample editing is done with AudioMaster III, from Aegis Development. AudioMaster has a more sophisticated effects menu than PerfectSound, and a better editing display.

Unfortunately, AudioMaster won't write files directly in raw format; files must be saved in IFF format and translated with a conversion utility which Aegis includes, `MakeRaw`.  The resulting file still has an 8 byte header, which contains the default sample rate for the sound and its length. DIGI doesn't use any of the header information, so I strip off the first 8 bytes of AudioMaster samples. The complete process looks like this:

- From AudioMaster, save a mono IFF sample, `BANG.IFF`, for example.
- Convert to raw format:

  ```
  > MAKERAW bang.iff bang.raw
  ```

- Strip out the header and all bytes with a value of `128` and add an end-of-sample marker:

  ```
  > DFILT -h8 bang.raw
  ```

  The resulting file can be included in a cart file by `HandyROM`, as shown above.
